업데이트 사항

2022-11-23

업데이트 이전 : 
업데이트 이후 : New크기변환과 목표각도 값을 통해 MaxFrame시간동안 회전이나 크기 변화가 가능하다
                    -> 각각 파티클에 적용되는 것이 아닌 전체에 적용

2022-11-24

업데이트 이전 : 빌보드 시 Scale 값에 따라서 크기가 고정
업데이트 이후 : 빌보드 시 Scale 값에 + rand(0 ~ Scale_Speed) 값이 더해져서 크기 설정
	        소프트 이펙트 적용하여 지형에 가려지면 사라지도록 구현 

=====================================================================================

설명서

< Pass >

2번 Pass
- Diffuse texture에 Color 적용가능한 패스
- BlackCut이나 Glow기능은 사용가능하지만 Noise는 적용 안된다.

3번 Pass
-  Diffuse texture에 인스턴스옵션에 있는 Color1, Color2 사용하는 패스 (Color는 사용하지 않는다.)
- 마찬가지로 BlackCut이나 Glow기능은 사용가능하지만 Noise는 적용 안된다.

< 툴 설명 >

- Transform은 적용 가능(각각 파티클에 적용되는 것이 아니다)
- NewScale과 Angle값을 통해 MaxFrame 값 동안 회전이나 크기 변화가 가능하다(마찬가지로 각각 파티클에 적용되는 것이 아니다)

- AlphaTime과 AlphaSpeed 적용 불가
- Render_Distortion 적용 불가

- 인스턴싱 옵션에서 값을 바꾼뒤 Play하면 바로 바뀌지 않고 한번 Play하고 한번더 Play해야 적용되는 문제 있음
- 인스턴싱 초기화 누르고 Play하면 바로 적용됨


< 파티클의 이동 속도>

초기 속도는 (툴 Speed + rand(0 ~ 툴 fSpeedRand))로 정해진다

KeyFrame_RelaxSpeed에 따라서 속도를 서서히 줄이거나 빠르게 할수 있다.
KeyFrame_RelaxSpeed는 매프레임 곱해지므로 작은 값(0.1)만으로도 큰 변화를 나타낸다.

※ 유의사항
만약 빌보드가 아닐 경우 파티클이 속도에 따라 찟어지므로 속도를 빠르게 할려고 바꿨다가 파티클이 엄청 찟어질 수 있다.
만약 속도는 점점 빠르게 하고 싶지만 안 찟어지고 싶으면 툴의 Scale_Speed(또는 Scale)를 바꿔주면 된다.

< 파티클의 이동 방향 >

초기 이동 방향은 Normalize(툴 vMovement + rand(0 ~ 툴 vMovementRand)) 로 정해진다.

매 프레임 KeyFrame_Movement만큼 더해진 후 Normalize를 해주므로 작은 값(0.1)으로도 큰 변화를 나타낸다.

< 파티클 크기 >

초기 크기는 (툴 Scale값)으로 정해진다.

빌보드의 경우 초기 크기가 유지된다.

빌보드가 아닌경우 툴 Scale_Speed와 각 파티클의 Speed의 영향을 받게 된다. => 파티클의 이동 속도 참고

Loop값이 0보다 큰 경우 Loop시간동안 파티클이 점점 작아진다

< Loop >

1. Loop값이 0일때

총 시간 : MaxFrame
KeyFrame 순서 : 1->2->3->4
	         KeyFrame1 : 0                      ~ MaxFrame * 0.25
	         KeyFrame2 : MaxFrame * 0.25 ~ MaxFrame * 0.5
	         KeyFrame3 : MaxFrame * 0.5   ~ MaxFrame * 0.75
	         KeyFrame4 : MaxFrame * 0.75 ~ MaxFrame * 1


1. Loop값이 0보다 클때

총 시간 : MaxFrame(Loop시간 기준으로 MaxFrame동안 반복)
KeyFrame 순서 : 4->3->2->1
	         KeyFrame4 : 0                    ~ LoopTime * 0.25
	         KeyFrame3 : LoopTime * 0.25 ~ LoopTime * 0.5
	         KeyFrame2 : LoopTime * 0.5   ~ LoopTime * 0.75
	         KeyFrame1 : LoopTime * 0.75 ~ LoopTime * 1

==========================================================================



































======================================================================================

빌보드일때 (Look과 이동방향이 다르다)

파티클 크기
초기값 : 툴 Scale값

파티클 Translation
초기값 : 툴 vPosition + rand(0 ~ 툴 vPositionRand)
이동값 : Pariticle의 각각의 vMovement방향으로 fLastTime만큼

==========================================================================

빌보드 아닐때 (Look과 이동방향이 같다)

< 파티클 크기>
초기값 : 툴 Scale값

파티클 Translation
초기값 : 툴 vPosition + rand(0 ~ 툴 vPositionRand)
이동값 : Pariticle의 각각의 vMovement방향(Look방향)으로 fLastTime만큼

===========================================================================

m_ParticleDesc 인자 설명

인자 fSpeed
초기값 : 툴 Speed + rand(0 ~ 툴 fSpeedRand)

인자 vMovement
초기값 : 툴 vMovement + rand(0 ~ 툴 vMovementRand)

인자 fTime
초기값 : rand(0 ~ 툴 fLoop)

================================================================================


1. fLoop가 0일때
KeyFram_1_TimeEnd = (m_EffectDesc.fMaxTime * 1) / 4;
KeyFram_2_TimeEnd = (m_EffectDesc.fMaxTime * 2) / 4;
KeyFram_3_TimeEnd = (m_EffectDesc.fMaxTime * 3) / 4;
KeyFram_4_TimeEnd = (m_EffectDesc.fMaxTime * 4) / 4;

< 초기값 >

각 파티클의 초기Scale : 툴 Scale값
각 파티클의 초기translation : 툴 vPosition + rand(0 ~ 툴 vPositionRand)
			+ Pariticle의 각각의 vMovement방향으로 fLastTime만큼

각 파티클의 초기 fSpeed : 툴 Speed + rand(0 ~ 툴 fSpeedRand)
각 파티클의 초기 vMovement : Normalize(툴 vMovement + rand(0 ~ 툴 vMovementRand))
각 파티클의 초기 fTime: 0

< Update시 >

=> 키프레임 값 : MaxTime시간 기준으로 사등분하여 1->2->3->4 순서대로 사용한다.

각 파티클의 fSpeed : Particle.fSpeed * KeyFrame_RelaxSpeed + KeyFrame_Speed * _dTimeDelta
각 파티클의 Movement : Normalize(Particle.Movement + KeyFrame_Movement)

각 파티클의 Transition : Particle.vMovement(Nor) * Particle.fSpeed * _dTimeDelta 만큼 더해짐

빌보드 아닐경우 
각 파티클의 Look : Particle.vMovement(Nor) * (툴 Scale + 툴 Scale * 툴 Scale_Speed * Particle.fSpeed)
	  늘어나는 정도가 정해진다.

======================================================================================

2. fLoop가 0보다 클때
KeyFram_1_TimeEnd = (m_EffectDesc.fLoop * 1) / 4;
KeyFram_2_TimeEnd = (m_EffectDesc.fLoop * 2) / 4;
KeyFram_3_TimeEnd = (m_EffectDesc.fLoop * 3) / 4;
KeyFram_4_TimeEnd = (m_EffectDesc.fLoop * 4) / 4;

< 초기값 >

각 파티클의 초기Scale : 툴 Scale값
각 파티클의 초기translation : 툴 vPosition + rand(0 ~ 툴 vPositionRand)
			+ Pariticle의 각각의 vMovement방향으로 fLastTime만큼

각 파티클의 초기 fSpeed : 툴 Speed + rand(0 ~ 툴 fSpeedRand)
각 파티클의 초기 vMovement : Normalize(툴 vMovement + rand(0 ~ 툴 vMovementRand))
각 파티클의 초기 fTime: rand(0 ~ 툴 fLoop)


< Update시 >

총 시간 : 툴 MaxTime + 툴 fLoop
Time : 총 남은 시간
Loop : 툴 fLoop

=> 남은 시간이 Loop시간보다 많을때 : 각 파티클 값을 초기화 해준다. 
				Particle.fTime만 fLoop로 해준다.
=> 남은 시간이 1초이하의 경우 없애버린다. => 필요한가?

=> 키프레임 값 : Loop시간 기준으로 사등분하여 4->3->2->1 순서대로 사용한다.


각 파티클의 fSpeed : Particle.fSpeed * KeyFrame_RelaxSpeed + KeyFrame_Speed * _dTimeDelta
각 파티클의 Movement : Normalize(Particle.Movement + KeyFrame_Movement)

각 파티클의 Transition : Particle.vMovement * Particle.fSpeed * _dTimeDelta 만큼 더해짐

빌보드한 경우
Right Up Look 크기 : (Particle.fTime(남은 시간) / Loop)

빌보드 아닐경우 
각 파티클의 Look : Particle.vMovement(Nor) * (툴 Size + 툴 Size * 툴 Size_Speed * Particle.fSpeed)
	  늘어나는 정도가 정해진다.
Right Up Look 크기 : 기존 크기 * (Particle.fTime(남은 시간) / Loop)

==========================================================================================










